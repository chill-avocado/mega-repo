"""
Hierarchical predictive processing module for the AGI system.

This module implements hierarchical predictive processing, a framework for understanding
cognition as a process of minimizing prediction errors at multiple levels of abstraction.
"""

import logging
import math
from typing import Any, Dict, List, Optional, Set, Tuple, Union, Callable

from ..interfaces.component import Component


class PredictiveModel:
    """
    Predictive model for a single level in the hierarchy.
    
    This class implements a predictive model that generates predictions and updates
    based on prediction errors.
    """
    
    def __init__(self, level: int, input_dim: int, hidden_dim: int, output_dim: int):
        """
        Initialize the predictive model.
        
        Args:
            level: The level in the hierarchy.
            input_dim: Dimension of input data.
            hidden_dim: Dimension of hidden layer.
            output_dim: Dimension of output predictions.
        """
        self.level = level
        self.input_dim = input_dim
        self.hidden_dim = hidden_dim
        self.output_dim = output_dim
        
        # Simple model parameters for demonstration purposes
        self.weights_input = [[0.1 for _ in range(input_dim)] for _ in range(hidden_dim)]
        self.weights_output = [[0.1 for _ in range(hidden_dim)] for _ in range(output_dim)]
        self.bias_hidden = [0.0 for _ in range(hidden_dim)]
        self.bias_output = [0.0 for _ in range(output_dim)]
        
        # State variables
        self.hidden_state = [0.0 for _ in range(hidden_dim)]
        self.prediction = [0.0 for _ in range(output_dim)]
        self.prediction_error = [0.0 for _ in range(output_dim)]
        self.precision = 1.0  # Inverse variance of prediction errors
        
        # Learning rate
        self.learning_rate = 0.01
    
    def predict(self, inputs: List[float]) -> List[float]:
        """
        Generate predictions based on inputs.
        
        Args:
            inputs: Input data.
        
        Returns:
            Predictions generated by the model.
        """
        # Forward pass through the model
        # Hidden layer
        self.hidden_state = [0.0 for _ in range(self.hidden_dim)]
        for i in range(self.hidden_dim):
            for j in range(self.input_dim):
                self.hidden_state[i] += inputs[j] * self.weights_input[i][j]
            self.hidden_state[i] += self.bias_hidden[i]
            # Apply ReLU activation
            self.hidden_state[i] = max(0, self.hidden_state[i])
        
        # Output layer
        self.prediction = [0.0 for _ in range(self.output_dim)]
        for i in range(self.output_dim):
            for j in range(self.hidden_dim):
                self.prediction[i] += self.hidden_state[j] * self.weights_output[i][j]
            self.prediction[i] += self.bias_output[i]
        
        return self.prediction
    
    def update(self, target: List[float]) -> float:
        """
        Update the model based on prediction errors.
        
        Args:
            target: Target values to compare predictions against.
        
        Returns:
            Mean squared prediction error.
        """
        # Calculate prediction errors
        self.prediction_error = [0.0 for _ in range(self.output_dim)]
        for i in range(self.output_dim):
            self.prediction_error[i] = target[i] - self.prediction[i]
        
        # Calculate mean squared error
        mse = sum(error ** 2 for error in self.prediction_error) / len(self.prediction_error)
        
        # Update weights and biases using simple gradient descent
        # Output layer
        for i in range(self.output_dim):
            for j in range(self.hidden_dim):
                self.weights_output[i][j] += self.learning_rate * self.prediction_error[i] * self.hidden_state[j] * self.precision
            self.bias_output[i] += self.learning_rate * self.prediction_error[i] * self.precision
        
        # Hidden layer (simplified backpropagation)
        hidden_errors = [0.0 for _ in range(self.hidden_dim)]
        for i in range(self.hidden_dim):
            for j in range(self.output_dim):
                hidden_errors[i] += self.prediction_error[j] * self.weights_output[j][i]
        
        # Only update weights for active hidden units (ReLU derivative)
        for i in range(self.hidden_dim):
            if self.hidden_state[i] > 0:  # ReLU derivative
                for j in range(self.input_dim):
                    self.weights_input[i][j] += self.learning_rate * hidden_errors[i] * self.precision
                self.bias_hidden[i] += self.learning_rate * hidden_errors[i] * self.precision
        
        return mse
    
    def set_precision(self, precision: float) -> None:
        """
        Set the precision (inverse variance) of prediction errors.
        
        Args:
            precision: The precision value to set.
        """
        self.precision = max(0.001, precision)  # Ensure precision is positive
    
    def get_state(self) -> Dict[str, Any]:
        """
        Get the current state of the model.
        
        Returns:
            Dictionary containing the current state.
        """
        return {
            'level': self.level,
            'input_dim': self.input_dim,
            'hidden_dim': self.hidden_dim,
            'output_dim': self.output_dim,
            'hidden_state': self.hidden_state.copy(),
            'prediction': self.prediction.copy(),
            'prediction_error': self.prediction_error.copy(),
            'precision': self.precision,
            'learning_rate': self.learning_rate
        }
    
    def set_state(self, state: Dict[str, Any]) -> bool:
        """
        Set the state of the model.
        
        Args:
            state: Dictionary containing the state to set.
        
        Returns:
            True if the state was set successfully, False otherwise.
        """
        try:
            if 'hidden_state' in state:
                self.hidden_state = state['hidden_state'].copy()
            
            if 'prediction' in state:
                self.prediction = state['prediction'].copy()
            
            if 'prediction_error' in state:
                self.prediction_error = state['prediction_error'].copy()
            
            if 'precision' in state:
                self.precision = state['precision']
            
            if 'learning_rate' in state:
                self.learning_rate = state['learning_rate']
            
            return True
        except Exception:
            return False


class HierarchicalPredictiveProcessing(Component):
    """
    Hierarchical predictive processing component.
    
    This class implements hierarchical predictive processing, a framework for understanding
    cognition as a process of minimizing prediction errors at multiple levels of abstraction.
    """
    
    def __init__(self):
        """Initialize hierarchical predictive processing."""
        self.logger = logging.getLogger(__name__)
        self.models = []
        self.config = {}
        self.initialized = False
        
        # Free energy (prediction error) at each level
        self.free_energy = []
        
        # Attention weights for each level
        self.attention_weights = []
    
    def initialize(self, config: Dict[str, Any]) -> bool:
        """
        Initialize the component with the given configuration.
        
        Args:
            config: Configuration dictionary for the component.
        
        Returns:
            True if initialization was successful, False otherwise.
        """
        self.logger.info("Initializing hierarchical predictive processing")
        
        try:
            self.config = config
            
            # Get hierarchy configuration
            hierarchy_config = config.get('hierarchy', [])
            
            # Create predictive models for each level in the hierarchy
            self.models = []
            for i, level_config in enumerate(hierarchy_config):
                input_dim = level_config.get('input_dim', 10)
                hidden_dim = level_config.get('hidden_dim', 20)
                output_dim = level_config.get('output_dim', 10)
                
                model = PredictiveModel(i, input_dim, hidden_dim, output_dim)
                self.models.append(model)
            
            # Initialize free energy and attention weights
            self.free_energy = [0.0 for _ in range(len(self.models))]
            self.attention_weights = [1.0 for _ in range(len(self.models))]
            
            self.initialized = True
            self.logger.info(f"Hierarchical predictive processing initialized with {len(self.models)} levels")
            return True
        
        except Exception as e:
            self.logger.error(f"Failed to initialize hierarchical predictive processing: {e}")
            return False
    
    def get_state(self) -> Dict[str, Any]:
        """
        Get the current state of the component.
        
        Returns:
            Dictionary containing the current state of the component.
        """
        model_states = [model.get_state() for model in self.models]
        
        return {
            'initialized': self.initialized,
            'config': self.config,
            'models': model_states,
            'free_energy': self.free_energy.copy(),
            'attention_weights': self.attention_weights.copy()
        }
    
    def set_state(self, state: Dict[str, Any]) -> bool:
        """
        Set the state of the component.
        
        Args:
            state: Dictionary containing the state to set.
        
        Returns:
            True if the state was set successfully, False otherwise.
        """
        try:
            if 'config' in state:
                self.config = state['config']
            
            if 'models' in state and len(state['models']) == len(self.models):
                for i, model_state in enumerate(state['models']):
                    self.models[i].set_state(model_state)
            
            if 'free_energy' in state:
                self.free_energy = state['free_energy'].copy()
            
            if 'attention_weights' in state:
                self.attention_weights = state['attention_weights'].copy()
            
            return True
        except Exception as e:
            self.logger.error(f"Failed to set state: {e}")
            return False
    
    def adjust(self, adjustment: Dict[str, Any]) -> bool:
        """
        Adjust the component based on meta-cognitive feedback.
        
        Args:
            adjustment: Dictionary containing the adjustment to apply.
        
        Returns:
            True if the adjustment was applied successfully, False otherwise.
        """
        try:
            # Adjust learning rates
            if 'learning_rates' in adjustment:
                learning_rates = adjustment['learning_rates']
                if len(learning_rates) == len(self.models):
                    for i, lr in enumerate(learning_rates):
                        self.models[i].learning_rate = lr
            
            # Adjust precisions
            if 'precisions' in adjustment:
                precisions = adjustment['precisions']
                if len(precisions) == len(self.models):
                    for i, precision in enumerate(precisions):
                        self.models[i].set_precision(precision)
            
            # Adjust attention weights
            if 'attention_weights' in adjustment:
                attention_weights = adjustment['attention_weights']
                if len(attention_weights) == len(self.attention_weights):
                    self.attention_weights = attention_weights.copy()
            
            return True
        except Exception as e:
            self.logger.error(f"Failed to apply adjustment: {e}")
            return False
    
    def process(self, inputs: List[float]) -> Dict[str, Any]:
        """
        Process inputs through the hierarchical predictive processing network.
        
        Args:
            inputs: Input data for the lowest level of the hierarchy.
        
        Returns:
            Dictionary containing processing results.
        """
        self.logger.debug("Processing inputs through hierarchical predictive processing")
        
        try:
            if not self.models:
                return {'success': False, 'error': 'No models initialized'}
            
            # Bottom-up pass: propagate prediction errors up the hierarchy
            bottom_up_inputs = inputs
            bottom_up_results = []
            
            for i, model in enumerate(self.models):
                # Generate predictions
                predictions = model.predict(bottom_up_inputs)
                
                # If this is not the top level, use predictions as inputs for the next level
                if i < len(self.models) - 1:
                    bottom_up_inputs = predictions
                
                bottom_up_results.append({
                    'level': i,
                    'predictions': predictions.copy()
                })
            
            # Top-down pass: update models based on prediction errors
            top_down_targets = None
            top_down_results = []
            
            for i in range(len(self.models) - 1, -1, -1):
                model = self.models[i]
                
                # For the top level, use its own predictions as targets (autoencoder-like)
                if i == len(self.models) - 1:
                    top_down_targets = model.prediction
                
                # Update the model
                prediction_error = model.update(top_down_targets)
                self.free_energy[i] = prediction_error
                
                # For lower levels, use this level's predictions as targets for the level below
                if i > 0:
                    top_down_targets = model.prediction
                
                top_down_results.append({
                    'level': i,
                    'prediction_error': prediction_error
                })
            
            # Update attention weights based on prediction errors
            self._update_attention_weights()
            
            return {
                'success': True,
                'bottom_up_results': bottom_up_results,
                'top_down_results': top_down_results,
                'free_energy': self.free_energy.copy(),
                'attention_weights': self.attention_weights.copy()
            }
        
        except Exception as e:
            self.logger.error(f"Failed to process inputs: {e}")
            return {'success': False, 'error': str(e)}
    
    def _update_attention_weights(self) -> None:
        """Update attention weights based on prediction errors."""
        # Calculate softmax of negative free energy (lower error = higher attention)
        neg_free_energy = [-fe for fe in self.free_energy]
        max_neg_fe = max(neg_free_energy)
        exp_neg_fe = [math.exp(nfe - max_neg_fe) for nfe in neg_free_energy]
        sum_exp = sum(exp_neg_fe)
        
        if sum_exp > 0:
            self.attention_weights = [exp / sum_exp for exp in exp_neg_fe]
        else:
            # Equal attention if all errors are the same
            self.attention_weights = [1.0 / len(self.free_energy) for _ in range(len(self.free_energy))]
    
    def predict(self, level: int, inputs: List[float]) -> Dict[str, Any]:
        """
        Generate predictions at a specific level of the hierarchy.
        
        Args:
            level: The level to generate predictions for.
            inputs: Input data for the specified level.
        
        Returns:
            Dictionary containing prediction results.
        """
        self.logger.debug(f"Generating predictions at level {level}")
        
        try:
            if level < 0 or level >= len(self.models):
                return {'success': False, 'error': f'Invalid level: {level}'}
            
            model = self.models[level]
            predictions = model.predict(inputs)
            
            return {
                'success': True,
                'level': level,
                'predictions': predictions.copy(),
                'attention_weight': self.attention_weights[level]
            }
        
        except Exception as e:
            self.logger.error(f"Failed to generate predictions: {e}")
            return {'success': False, 'error': str(e)}
    
    def get_free_energy(self) -> List[float]:
        """
        Get the free energy (prediction error) at each level of the hierarchy.
        
        Returns:
            List of free energy values.
        """
        return self.free_energy.copy()
    
    def get_attention_weights(self) -> List[float]:
        """
        Get the attention weights for each level of the hierarchy.
        
        Returns:
            List of attention weights.
        """
        return self.attention_weights.copy()
    
    def learn(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Learn from data using hierarchical predictive processing.
        
        Args:
            data: Dictionary containing data to learn from.
        
        Returns:
            Dictionary containing learning results.
        """
        self.logger.info("Learning from data using hierarchical predictive processing")
        
        try:
            results = []
            
            # Get input sequences
            input_sequences = data.get('input_sequences', [])
            
            # Process each input sequence
            for i, inputs in enumerate(input_sequences):
                sequence_results = self.process(inputs)
                results.append(sequence_results)
            
            # Calculate average free energy across all sequences
            avg_free_energy = [0.0 for _ in range(len(self.models))]
            for result in results:
                if result['success'] and 'free_energy' in result:
                    for i, fe in enumerate(result['free_energy']):
                        avg_free_energy[i] += fe
            
            if input_sequences:
                avg_free_energy = [fe / len(input_sequences) for fe in avg_free_energy]
            
            return {
                'success': True,
                'sequences_processed': len(input_sequences),
                'avg_free_energy': avg_free_energy,
                'attention_weights': self.attention_weights.copy()
            }
        
        except Exception as e:
            self.logger.error(f"Failed to learn from data: {e}")
            return {'success': False, 'error': str(e)}
    
    def generate(self, level: int, steps: int) -> Dict[str, Any]:
        """
        Generate a sequence by running the model in generative mode.
        
        Args:
            level: The level to start generation from.
            steps: Number of steps to generate.
        
        Returns:
            Dictionary containing generated sequence.
        """
        self.logger.info(f"Generating sequence from level {level} for {steps} steps")
        
        try:
            if level < 0 or level >= len(self.models):
                return {'success': False, 'error': f'Invalid level: {level}'}
            
            # Start with random input for the specified level
            import random
            input_dim = self.models[level].input_dim
            inputs = [random.random() for _ in range(input_dim)]
            
            generated_sequence = []
            
            for _ in range(steps):
                # Generate predictions at the specified level
                predictions = self.models[level].predict(inputs)
                generated_sequence.append(predictions.copy())
                
                # Use predictions as next inputs (autoregressive generation)
                inputs = predictions
            
            return {
                'success': True,
                'level': level,
                'steps': steps,
                'generated_sequence': generated_sequence
            }
        
        except Exception as e:
            self.logger.error(f"Failed to generate sequence: {e}")
            return {'success': False, 'error': str(e)}
    
    def get_abstractions(self, level: int) -> Dict[str, Any]:
        """
        Get abstractions learned at a specific level of the hierarchy.
        
        Args:
            level: The level to get abstractions for.
        
        Returns:
            Dictionary containing abstractions.
        """
        self.logger.debug(f"Getting abstractions at level {level}")
        
        try:
            if level < 0 or level >= len(self.models):
                return {'success': False, 'error': f'Invalid level: {level}'}
            
            model = self.models[level]
            
            # Extract abstractions from the model's weights
            # In a real implementation, this would use more sophisticated methods
            abstractions = {
                'weights_input': [row.copy() for row in model.weights_input],
                'weights_output': [row.copy() for row in model.weights_output],
                'bias_hidden': model.bias_hidden.copy(),
                'bias_output': model.bias_output.copy()
            }
            
            return {
                'success': True,
                'level': level,
                'abstractions': abstractions
            }
        
        except Exception as e:
            self.logger.error(f"Failed to get abstractions: {e}")
            return {'success': False, 'error': str(e)}